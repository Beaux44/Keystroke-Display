use std::sync::{Arc, Mutex};
use inputbot::{KeybdKey, KeybdKey::*};
use inputbot;
use message_io::node::{self, NodeEvent};
use message_io::network::{NetEvent, Transport};
use std::thread;

enum Signal {
    KeyPress(KeybdKey, bool, bool),
}

fn main() {
    let (handler, listener) = node::split();
    let (server, _) = handler.network().connect(Transport::Ws, "127.0.0.1:8000").unwrap();

    let handler2 = Arc::new(Mutex::new(handler));
    let handler3 = handler2.clone();


    KeybdKey::bind_all(move |event| {
        match event {
            LShiftKey | LControlKey => {}
            _ => handler2.lock()
                         .unwrap()
                         .signals()
                         .send(Signal::KeyPress(event,
                               LControlKey.is_pressed(),
                               LShiftKey.is_pressed()))
        }
    });


    thread::spawn(inputbot::handle_input_events);

    listener.for_each(move |event| match event {
        NodeEvent::Network(net_event) => match net_event {
            NetEvent::Connected(_endpoint, _ok) => {}
            NetEvent::Accepted(_, _) => unreachable!(), // Only generated by listening
            NetEvent::Message(_endpoint, data) => {
                println!("Received: {}", String::from_utf8_lossy(data));
            },
            NetEvent::Disconnected(_endpoint) => (),
        }
        NodeEvent::Signal(signal) => match signal {
            Signal::KeyPress(e, c, s) => {
                let h = handler3.lock().unwrap();
                h.network().send(server, format!("{e:?},{c},{s}").as_bytes());
            }
        }
    });
}

